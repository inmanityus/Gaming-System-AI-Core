# Comprehensive Security Rules

## Overview
These rules provide comprehensive security guidelines for all development work in Cursor, ensuring applications are secure by design and follow industry best practices.

## Authentication and Authorization

### Authentication Best Practices
- **Use strong password policies** with minimum 12 characters, mixed case, numbers, and symbols
- **Implement multi-factor authentication** (MFA) for all user accounts
- **Use secure session management** with proper expiration and rotation
- **Implement proper JWT handling** with secure storage and transmission
- **Use OAuth 2.0** for third-party authentication when appropriate
- **Implement proper account lockout** policies after failed attempts
- **Use secure password reset** mechanisms with time-limited tokens
- **Implement proper user registration** validation and verification

#### Authentication Implementation Examples
```javascript
// JWT Authentication Service
const jwt = require('jsonwebtoken');
const bcrypt = require('bcryptjs');
const crypto = require('crypto');

class AuthService {
  constructor() {
    this.jwtSecret = process.env.JWT_SECRET;
    this.jwtExpiry = '24h';
    this.refreshTokenExpiry = '7d';
    this.bcryptRounds = 12;
  }
  
  async hashPassword(password) {
    return await bcrypt.hash(password, this.bcryptRounds);
  }
  
  async verifyPassword(password, hash) {
    return await bcrypt.compare(password, hash);
  }
  
  generateTokenPair(user) {
    const payload = {
      userId: user.id,
      email: user.email,
      role: user.role,
      iat: Math.floor(Date.now() / 1000)
    };
    
    const accessToken = jwt.sign(payload, this.jwtSecret, {
      expiresIn: this.jwtExpiry,
      issuer: 'your-app',
      audience: 'your-app-users'
    });
    
    const refreshToken = jwt.sign(
      { userId: user.id, type: 'refresh' },
      this.jwtSecret,
      { expiresIn: this.refreshTokenExpiry }
    );
    
    return { accessToken, refreshToken };
  }
  
  verifyToken(token) {
    try {
      return jwt.verify(token, this.jwtSecret, {
        issuer: 'your-app',
        audience: 'your-app-users'
      });
    } catch (error) {
      throw new Error('Invalid token');
    }
  }
  
  generateSecureToken() {
    return crypto.randomBytes(32).toString('hex');
  }
}

// Password Policy Validation
class PasswordPolicy {
  static validate(password) {
    const errors = [];
    
    if (password.length < 12) {
      errors.push('Password must be at least 12 characters long');
    }
    
    if (!/[a-z]/.test(password)) {
      errors.push('Password must contain at least one lowercase letter');
    }
    
    if (!/[A-Z]/.test(password)) {
      errors.push('Password must contain at least one uppercase letter');
    }
    
    if (!/[0-9]/.test(password)) {
      errors.push('Password must contain at least one number');
    }
    
    if (!/[^a-zA-Z0-9]/.test(password)) {
      errors.push('Password must contain at least one special character');
    }
    
    // Check against common passwords
    const commonPasswords = ['password', '123456', 'qwerty', 'admin'];
    if (commonPasswords.includes(password.toLowerCase())) {
      errors.push('Password is too common');
    }
    
    return {
      isValid: errors.length === 0,
      errors
    };
  }
}
```

### Authorization Best Practices
- **Implement role-based access control** (RBAC) with proper permission inheritance
- **Use principle of least privilege** - grant minimum necessary permissions
- **Implement proper resource-level authorization** for sensitive operations
- **Use attribute-based access control** (ABAC) for complex scenarios
- **Implement proper session management** with role-based restrictions
- **Use proper API authorization** with scoped permissions
- **Implement proper audit logging** for authorization decisions
- **Use proper privilege escalation** controls and approval workflows

#### Authorization Implementation Examples
```javascript
// Role-Based Access Control
class RBACService {
  constructor() {
    this.roles = {
      'admin': ['read', 'write', 'delete', 'manage_users'],
      'moderator': ['read', 'write', 'moderate'],
      'user': ['read', 'write_own'],
      'guest': ['read']
    };
    
    this.resources = {
      'users': ['read', 'write', 'delete'],
      'posts': ['read', 'write', 'delete', 'moderate'],
      'comments': ['read', 'write', 'delete', 'moderate']
    };
  }
  
  hasPermission(userRole, resource, action) {
    const rolePermissions = this.roles[userRole] || [];
    const resourceActions = this.resources[resource] || [];
    
    return rolePermissions.includes(action) && resourceActions.includes(action);
  }
  
  canAccessResource(userRole, resource, action) {
    // Check if user has permission for the action
    if (!this.hasPermission(userRole, resource, action)) {
      return false;
    }
    
    // Additional business logic checks
    return this.validateBusinessRules(userRole, resource, action);
  }
  
  validateBusinessRules(userRole, resource, action) {
    // Implement business-specific authorization rules
    switch (resource) {
      case 'users':
        return userRole === 'admin';
      case 'posts':
        return ['admin', 'moderator', 'user'].includes(userRole);
      case 'comments':
        return ['admin', 'moderator', 'user'].includes(userRole);
      default:
        return false;
    }
  }
}

// Authorization Middleware
const requireAuth = (req, res, next) => {
  const token = req.headers.authorization?.split(' ')[1];
  
  if (!token) {
    return res.status(401).json({ error: 'No token provided' });
  }
  
  try {
    const decoded = authService.verifyToken(token);
    req.user = decoded;
    next();
  } catch (error) {
    return res.status(401).json({ error: 'Invalid token' });
  }
};

const requirePermission = (resource, action) => {
  return (req, res, next) => {
    if (!req.user) {
      return res.status(401).json({ error: 'Authentication required' });
    }
    
    const userRole = req.user.role;
    if (!rbacService.canAccessResource(userRole, resource, action)) {
      return res.status(403).json({ error: 'Insufficient permissions' });
    }
    
    next();
  };
};
```

## Input Validation and Sanitization

### Input Validation Best Practices
- **Validate all inputs** on both client and server sides
- **Use proper data types** and constraints for all inputs
- **Implement proper length limits** and format validation
- **Use whitelist validation** instead of blacklist validation
- **Implement proper file upload** validation and scanning
- **Use proper encoding** for all data transmission
- **Implement proper error handling** without information leakage
- **Use proper validation libraries** and frameworks

#### Input Validation Examples
```javascript
const Joi = require('joi');
const validator = require('validator');
const xss = require('xss');

class InputValidator {
  // User registration validation
  static validateUserRegistration(data) {
    const schema = Joi.object({
      email: Joi.string()
        .email()
        .required()
        .max(255)
        .custom((value) => {
          if (!validator.isEmail(value)) {
            throw new Error('Invalid email format');
          }
          return value.toLowerCase();
        }),
      password: Joi.string()
        .min(12)
        .max(128)
        .required()
        .custom((value) => {
          const policy = PasswordPolicy.validate(value);
          if (!policy.isValid) {
            throw new Error(policy.errors.join(', '));
          }
          return value;
        }),
      firstName: Joi.string()
        .min(1)
        .max(100)
        .required()
        .pattern(/^[a-zA-Z\s]+$/)
        .custom((value) => xss(value.trim())),
      lastName: Joi.string()
        .min(1)
        .max(100)
        .required()
        .pattern(/^[a-zA-Z\s]+$/)
        .custom((value) => xss(value.trim())),
      role: Joi.string()
        .valid('user', 'moderator', 'admin')
        .default('user')
    });
    
    return schema.validate(data, { abortEarly: false });
  }
  
  // File upload validation
  static validateFileUpload(file) {
    const allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'application/pdf'];
    const maxSize = 5 * 1024 * 1024; // 5MB
    
    if (!allowedTypes.includes(file.mimetype)) {
      throw new Error('Invalid file type');
    }
    
    if (file.size > maxSize) {
      throw new Error('File too large');
    }
    
    // Additional security checks
    if (file.originalname.includes('..') || file.originalname.includes('/')) {
      throw new Error('Invalid filename');
    }
    
    return true;
  }
  
  // SQL injection prevention
  static sanitizeSQLInput(input) {
    if (typeof input !== 'string') {
      return input;
    }
    
    // Remove potentially dangerous characters
    return input
      .replace(/['"\\]/g, '') // Remove quotes and backslashes
      .replace(/[;--]/g, '') // Remove SQL comment markers
      .replace(/union/gi, '') // Remove UNION keywords
      .replace(/select/gi, '') // Remove SELECT keywords
      .replace(/insert/gi, '') // Remove INSERT keywords
      .replace(/update/gi, '') // Remove UPDATE keywords
      .replace(/delete/gi, '') // Remove DELETE keywords
      .replace(/drop/gi, '') // Remove DROP keywords
      .trim();
  }
  
  // XSS prevention
  static sanitizeHTML(input) {
    if (typeof input !== 'string') {
      return input;
    }
    
    return xss(input, {
      whiteList: {
        p: [],
        br: [],
        strong: [],
        em: [],
        u: []
      },
      stripIgnoreTag: true,
      stripIgnoreTagBody: ['script']
    });
  }
}
```

### Data Sanitization Best Practices
- **Sanitize all user inputs** before processing or storage
- **Use proper HTML sanitization** to prevent XSS attacks
- **Implement proper SQL injection** prevention with parameterized queries
- **Use proper file upload** sanitization and scanning
- **Implement proper data encoding** for different contexts
- **Use proper validation libraries** with built-in sanitization
- **Implement proper error handling** without information leakage
- **Use proper logging** without sensitive data exposure

## Data Protection and Encryption

### Encryption Best Practices
- **Encrypt sensitive data** at rest using AES-256 or stronger
- **Use proper key management** with key rotation and secure storage
- **Implement proper data encryption** in transit using TLS 1.3+
- **Use proper database encryption** for sensitive fields
- **Implement proper backup encryption** for data protection
- **Use proper file encryption** for sensitive documents
- **Implement proper session encryption** for secure communication
- **Use proper API encryption** for sensitive data transmission

#### Encryption Implementation Examples
```javascript
const crypto = require('crypto');
const bcrypt = require('bcryptjs');

class EncryptionService {
  constructor() {
    this.algorithm = 'aes-256-gcm';
    this.keyLength = 32;
    this.ivLength = 16;
    this.tagLength = 16;
    this.saltLength = 16;
  }
  
  // Generate secure encryption key
  generateKey() {
    return crypto.randomBytes(this.keyLength);
  }
  
  // Generate secure IV
  generateIV() {
    return crypto.randomBytes(this.ivLength);
  }
  
  // Encrypt data
  encrypt(data, key) {
    try {
      const iv = this.generateIV();
      const cipher = crypto.createCipher(this.algorithm, key);
      cipher.setAAD(Buffer.from('additional-data', 'utf8'));
      
      let encrypted = cipher.update(data, 'utf8', 'hex');
      encrypted += cipher.final('hex');
      
      const tag = cipher.getAuthTag();
      
      return {
        encrypted,
        iv: iv.toString('hex'),
        tag: tag.toString('hex')
      };
    } catch (error) {
      throw new Error('Encryption failed');
    }
  }
  
  // Decrypt data
  decrypt(encryptedData, key, iv, tag) {
    try {
      const decipher = crypto.createDecipher(this.algorithm, key);
      decipher.setAAD(Buffer.from('additional-data', 'utf8'));
      decipher.setAuthTag(Buffer.from(tag, 'hex'));
      
      let decrypted = decipher.update(encryptedData, 'hex', 'utf8');
      decrypted += decipher.final('utf8');
      
      return decrypted;
    } catch (error) {
      throw new Error('Decryption failed');
    }
  }
  
  // Hash password securely
  async hashPassword(password) {
    const salt = await bcrypt.genSalt(12);
    return await bcrypt.hash(password, salt);
  }
  
  // Verify password
  async verifyPassword(password, hash) {
    return await bcrypt.compare(password, hash);
  }
  
  // Generate secure random token
  generateSecureToken(length = 32) {
    return crypto.randomBytes(length).toString('hex');
  }
  
  // Generate secure random string
  generateSecureString(length = 16) {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    let result = '';
    for (let i = 0; i < length; i++) {
      result += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return result;
  }
}
```

### Data Protection Best Practices
- **Implement proper data classification** for sensitive information
- **Use proper data retention** policies and automated cleanup
- **Implement proper data anonymization** for analytics and testing
- **Use proper data masking** for non-production environments
- **Implement proper data backup** encryption and secure storage
- **Use proper data disposal** procedures for sensitive information
- **Implement proper data access** logging and monitoring
- **Use proper data privacy** compliance (GDPR, CCPA, etc.)

## Network Security

### HTTPS and TLS Best Practices
- **Use HTTPS only** for all web communications
- **Implement proper TLS 1.3** configuration with strong ciphers
- **Use proper certificate management** with automatic renewal
- **Implement proper HSTS** headers for security
- **Use proper certificate pinning** for mobile applications
- **Implement proper SSL/TLS** monitoring and alerting
- **Use proper cipher suite** configuration for security
- **Implement proper certificate** validation and verification

#### Network Security Implementation Examples
```javascript
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');

// Security headers middleware
const securityHeaders = helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      scriptSrc: ["'self'"],
      imgSrc: ["'self'", "data:", "https:"],
      connectSrc: ["'self'"],
      fontSrc: ["'self'"],
      objectSrc: ["'none'"],
      mediaSrc: ["'self'"],
      frameSrc: ["'none'"]
    }
  },
  hsts: {
    maxAge: 31536000,
    includeSubDomains: true,
    preload: true
  },
  xssFilter: true,
  noSniff: true,
  frameguard: { action: 'deny' },
  referrerPolicy: { policy: 'same-origin' }
});

// Rate limiting middleware
const rateLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // limit each IP to 100 requests per windowMs
  message: 'Too many requests from this IP, please try again later.',
  standardHeaders: true,
  legacyHeaders: false
});

// Strict rate limiting for sensitive endpoints
const strictRateLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 5, // limit each IP to 5 requests per windowMs
  message: 'Too many requests from this IP, please try again later.',
  standardHeaders: true,
  legacyHeaders: false
});

// CORS configuration
const corsOptions = {
  origin: function (origin, callback) {
    const allowedOrigins = process.env.ALLOWED_ORIGINS?.split(',') || ['http://localhost:3000'];
    
    if (!origin || allowedOrigins.includes(origin)) {
      callback(null, true);
    } else {
      callback(new Error('Not allowed by CORS'));
    }
  },
  credentials: true,
  optionsSuccessStatus: 200,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With']
};
```

### API Security Best Practices
- **Implement proper API authentication** with secure tokens
- **Use proper API rate limiting** to prevent abuse
- **Implement proper API versioning** for security updates
- **Use proper API documentation** with security considerations
- **Implement proper API monitoring** and logging
- **Use proper API validation** for all inputs
- **Implement proper API error handling** without information leakage
- **Use proper API security testing** and vulnerability assessment

## Application Security

### Secure Coding Practices
- **Use secure coding standards** and guidelines
- **Implement proper error handling** without information leakage
- **Use proper logging** without sensitive data exposure
- **Implement proper session management** with secure storage
- **Use proper input validation** and sanitization
- **Implement proper output encoding** for different contexts
- **Use proper authentication** and authorization controls
- **Implement proper security testing** and code review

#### Secure Coding Examples
```javascript
// Secure error handling
class SecureErrorHandler {
  static handleError(error, req, res, next) {
    // Log error securely without exposing sensitive information
    console.error('Error occurred:', {
      timestamp: new Date().toISOString(),
      method: req.method,
      url: req.url,
      userAgent: req.get('User-Agent'),
      ip: req.ip,
      error: error.message,
      stack: process.env.NODE_ENV === 'development' ? error.stack : undefined
    });
    
    // Return generic error message to client
    if (error.name === 'ValidationError') {
      return res.status(400).json({
        error: 'Invalid input data',
        details: error.details?.map(d => d.message) || []
      });
    }
    
    if (error.name === 'UnauthorizedError') {
      return res.status(401).json({
        error: 'Authentication required'
      });
    }
    
    if (error.name === 'ForbiddenError') {
      return res.status(403).json({
        error: 'Access denied'
      });
    }
    
    // Generic error response
    res.status(500).json({
      error: 'Internal server error'
    });
  }
}

// Secure logging
class SecureLogger {
  static log(level, message, data = {}) {
    const logEntry = {
      timestamp: new Date().toISOString(),
      level,
      message,
      ...this.sanitizeData(data)
    };
    
    console.log(JSON.stringify(logEntry));
  }
  
  static sanitizeData(data) {
    const sensitiveFields = ['password', 'token', 'secret', 'key', 'ssn', 'creditCard'];
    const sanitized = { ...data };
    
    for (const field of sensitiveFields) {
      if (sanitized[field]) {
        sanitized[field] = '[REDACTED]';
      }
    }
    
    return sanitized;
  }
}
```

### Security Testing Best Practices
- **Implement proper security testing** in CI/CD pipelines
- **Use proper vulnerability scanning** tools and services
- **Implement proper penetration testing** and security audits
- **Use proper security code review** processes and tools
- **Implement proper security monitoring** and alerting
- **Use proper incident response** procedures and training
- **Implement proper security training** for development teams
- **Use proper security metrics** and reporting

## Compliance and Privacy

### Data Privacy Best Practices
- **Implement proper data privacy** controls and procedures
- **Use proper consent management** for data collection
- **Implement proper data subject rights** (access, rectification, deletion)
- **Use proper data minimization** principles
- **Implement proper data protection** by design and default
- **Use proper privacy impact** assessments
- **Implement proper data breach** notification procedures
- **Use proper privacy training** and awareness

### Compliance Best Practices
- **Implement proper compliance** monitoring and reporting
- **Use proper audit logging** for compliance requirements
- **Implement proper data retention** policies and procedures
- **Use proper access controls** for compliance requirements
- **Implement proper security controls** for compliance frameworks
- **Use proper documentation** for compliance requirements
- **Implement proper training** for compliance requirements
- **Use proper monitoring** and alerting for compliance violations

## Security Monitoring and Incident Response

### Security Monitoring Best Practices
- **Implement proper security monitoring** and alerting
- **Use proper log analysis** and correlation
- **Implement proper threat detection** and response
- **Use proper security metrics** and reporting
- **Implement proper incident response** procedures
- **Use proper security training** and awareness
- **Implement proper security testing** and validation
- **Use proper security documentation** and procedures

### Incident Response Best Practices
- **Implement proper incident response** procedures and training
- **Use proper incident classification** and prioritization
- **Implement proper incident containment** and recovery
- **Use proper incident communication** and notification
- **Implement proper incident analysis** and lessons learned
- **Use proper incident documentation** and reporting
- **Implement proper incident testing** and validation
- **Use proper incident metrics** and improvement

These security rules ensure comprehensive protection across all aspects of application development, from authentication and authorization to data protection and incident response.