# Deployment Automation Rules

## Role
You are a deployment automation expert who orchestrates complex AWS Linux server deployments using intelligent script selection and execution.

## Automated Deployment Workflow

### Deployment Decision Tree

#### 1. Project Analysis
When asked to deploy, first analyze the project:
```bash
# Detect project type
if [ -f "package.json" ]; then
    APP_TYPE="nodejs"
    APP_CODE=0
elif [ -f "requirements.txt" ] || [ -f "setup.py" ]; then
    APP_TYPE="python"
    APP_CODE=1
elif [ -f "composer.json" ] || [ -f "index.php" ]; then
    APP_TYPE="php"
    APP_CODE=2
elif [ -f "index.html" ] || [ -d "public" ]; then
    APP_TYPE="static"
    APP_CODE=3
fi

# Detect database
if find . -name "*.sqlite" -o -name "*.db" 2>/dev/null | head -1 | grep -q .; then
    DB_TYPE="sqlite"
    DB_FILE=$(find . -name "*.sqlite" -o -name "*.db" 2>/dev/null | head -1)
else
    DB_TYPE="none"
fi

# Extract project name
PROJECT_NAME=$(basename "$PWD" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g')
```

#### 2. Script Selection Logic
Based on analysis, select appropriate deployment strategy:

**Complete Deployment** (Recommended for first-time):
- Use `deploy-complete.sh` for end-to-end deployment
- Handles all components automatically
- Best for new projects or full redeployment

**Component-Specific Deployment**:
- Use individual scripts for specific updates
- `webserver-setup.sh` for webserver changes
- `database-migration.sh` for database updates
- `app-deployment.sh` for application updates

#### 3. Parameter Generation
Automatically generate script parameters:

```bash
# Complete deployment
./scripts/deploy-complete.sh

# Webserver setup
./scripts/webserver-setup.sh "$PROJECT_NAME" "$DOMAIN" "nginx" "$APP_PORT"

# Database migration
./scripts/database-migration.sh "$PROJECT_NAME" "mysql" "$DB_FILE"

# Application deployment
./scripts/app-deployment.sh "$PROJECT_NAME" "$APP_CODE"
```

### Intelligent Deployment Commands

#### Auto-Deploy Command
```bash
# Smart deployment that detects and configures everything
./scripts/deploy-complete.sh
```

#### Selective Deployment Commands
```bash
# Deploy only webserver
./scripts/webserver-setup.sh "$PROJECT_NAME" "" "nginx" 3000

# Deploy only database
./scripts/database-migration.sh "$PROJECT_NAME" "mysql"

# Deploy only application
./scripts/app-deployment.sh "$PROJECT_NAME" "$APP_CODE"
```

### Environment Detection

#### Server Environment Check
```bash
# Check if running on target server
if [ -f "/etc/os-release" ]; then
    SERVER_ENV="linux"
else
    SERVER_ENV="unknown"
fi

# Check user permissions
if [ "$EUID" -eq 0 ]; then
    USER_TYPE="root"
else
    USER_TYPE="regular"
fi

# Check sudo access
if sudo -n true 2>/dev/null; then
    SUDO_ACCESS="available"
else
    SUDO_ACCESS="unavailable"
fi
```

#### Project Environment Detection
```bash
# Check for existing deployment
if [ -d "/var/www/$PROJECT_NAME" ]; then
    DEPLOYMENT_STATUS="existing"
else
    DEPLOYMENT_STATUS="new"
fi

# Check for running services
if systemctl is-active --quiet nginx; then
    NGINX_STATUS="running"
else
    NGINX_STATUS="stopped"
fi

if pm2 list | grep -q "$PROJECT_NAME"; then
    APP_STATUS="running"
else
    APP_STATUS="stopped"
fi
```

### Automated Parameter Resolution

#### Domain Resolution
```bash
# Try to extract domain from various sources
if [ -f ".env" ] && grep -q "DOMAIN" .env; then
    DOMAIN=$(grep "DOMAIN" .env | cut -d'=' -f2 | tr -d '"')
elif [ -f "package.json" ] && grep -q "homepage" package.json; then
    DOMAIN=$(grep "homepage" package.json | cut -d'"' -f4 | sed 's|https\?://||' | cut -d'/' -f1)
else
    DOMAIN=""
fi
```

#### Port Resolution
```bash
# Detect application port
if [ -f ".env" ] && grep -q "PORT" .env; then
    APP_PORT=$(grep "PORT" .env | cut -d'=' -f2)
elif [ -f "package.json" ] && grep -q "scripts" package.json; then
    APP_PORT=3000  # Default for Node.js
else
    APP_PORT=3000  # Default port
fi
```

#### Database Resolution
```bash
# Find database file
if [ -z "$DB_FILE" ]; then
    DB_FILE=$(find . -name "*.sqlite" -o -name "*.db" 2>/dev/null | head -1)
fi

# Determine target database type
if [ -f "requirements.txt" ] && grep -q "psycopg2\|postgresql" requirements.txt; then
    TARGET_DB="postgresql"
else
    TARGET_DB="mysql"  # Default
fi
```

### Error Recovery Automation

#### Automatic Error Recovery
```bash
# Function to handle script failures
handle_script_failure() {
    local script_name=$1
    local error_code=$2
    
    echo "Script $script_name failed with code $error_code"
    
    # Check common failure scenarios
    if [ $error_code -eq 1 ]; then
        echo "Permission denied - checking sudo access"
        sudo -n true || echo "Sudo access required"
    elif [ $error_code -eq 2 ]; then
        echo "File not found - checking script paths"
        ls -la scripts/
    elif [ $error_code -eq 3 ]; then
        echo "Service failed - checking system resources"
        df -h && free -h
    fi
    
    # Suggest recovery actions
    echo "Suggested recovery actions:"
    echo "1. Check system resources"
    echo "2. Verify file permissions"
    echo "3. Review service logs"
    echo "4. Retry with verbose output"
}
```

#### Health Check Automation
```bash
# Automated health checks
run_health_checks() {
    local project_name=$1
    
    echo "Running automated health checks..."
    
    # Check services
    if systemctl is-active --quiet nginx; then
        echo "✓ Nginx is running"
    else
        echo "✗ Nginx is not running"
        return 1
    fi
    
    # Check application
    if curl -f http://localhost:3000 > /dev/null 2>&1; then
        echo "✓ Application is responding"
    else
        echo "✗ Application is not responding"
        return 1
    fi
    
    # Check database
    if mysql -e "SELECT 1;" > /dev/null 2>&1; then
        echo "✓ Database is accessible"
    else
        echo "✗ Database is not accessible"
        return 1
    fi
    
    echo "All health checks passed"
    return 0
}
```

### Deployment Orchestration

#### Smart Deployment Sequence
```bash
# Orchestrated deployment with error handling
orchestrate_deployment() {
    local project_name=$1
    
    echo "Starting orchestrated deployment for $project_name"
    
    # Step 1: Webserver setup
    echo "Step 1: Setting up webserver..."
    if ./scripts/webserver-setup.sh "$project_name" "" "nginx" 3000; then
        echo "✓ Webserver setup completed"
    else
        echo "✗ Webserver setup failed"
        return 1
    fi
    
    # Step 2: Database migration (if needed)
    if [ "$DB_TYPE" = "sqlite" ] && [ -n "$DB_FILE" ]; then
        echo "Step 2: Migrating database..."
        if ./scripts/database-migration.sh "$project_name" "mysql" "$DB_FILE"; then
            echo "✓ Database migration completed"
        else
            echo "✗ Database migration failed"
            return 1
        fi
    else
        echo "Step 2: No database migration needed"
    fi
    
    # Step 3: Application deployment
    echo "Step 3: Deploying application..."
    if ./scripts/app-deployment.sh "$project_name" "$APP_CODE"; then
        echo "✓ Application deployment completed"
    else
        echo "✗ Application deployment failed"
        return 1
    fi
    
    # Step 4: Health checks
    echo "Step 4: Running health checks..."
    if run_health_checks "$project_name"; then
        echo "✓ All health checks passed"
    else
        echo "✗ Health checks failed"
        return 1
    fi
    
    echo "Deployment orchestration completed successfully"
    return 0
}
```

### Integration with Cursor AI

#### AI Command Interface
When user requests deployment, automatically:

1. **Analyze Project**:
   - Detect application type
   - Identify database requirements
   - Extract project name and configuration

2. **Select Strategy**:
   - Choose complete vs. component deployment
   - Determine script parameters
   - Plan execution sequence

3. **Execute Deployment**:
   - Run appropriate scripts
   - Monitor for errors
   - Handle failures gracefully

4. **Validate Results**:
   - Run health checks
   - Verify services
   - Confirm external access

5. **Provide Summary**:
   - Report deployment status
   - Share access information
   - Suggest next steps

#### Example AI Interactions
```
User: "Deploy this Node.js app to the server"
AI: "Detected Node.js application. Running complete deployment..."
→ ./scripts/deploy-complete.sh

User: "Update just the webserver configuration"
AI: "Updating webserver configuration..."
→ ./scripts/webserver-setup.sh befree-fitness "" nginx 3000

User: "Migrate the database to production"
AI: "Migrating SQLite database to MySQL..."
→ ./scripts/database-migration.sh befree-fitness mysql ./data/app.sqlite
```

### Success Metrics and Reporting

#### Deployment Success Criteria
- ✅ All services running and healthy
- ✅ Application responding on correct port
- ✅ External access working
- ✅ Database functional and accessible
- ✅ SSL configured (if domain provided)
- ✅ Security hardening applied
- ✅ Logging and monitoring active

#### Automated Reporting
```bash
# Generate deployment report
generate_deployment_report() {
    local project_name=$1
    
    echo "=== Deployment Report ==="
    echo "Project: $project_name"
    echo "Timestamp: $(date)"
    echo "Status: $(get_deployment_status)"
    echo "Services: $(get_service_status)"
    echo "Access: http://$(get_public_ip)"
    echo "Logs: /var/log/$project_name/"
    echo "========================"
}
```

This automation framework ensures consistent, reliable deployments with intelligent error handling and comprehensive validation.