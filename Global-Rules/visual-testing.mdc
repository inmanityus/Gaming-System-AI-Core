# Visual Testing Workflow Rules

## Overview
This rule enables Cursor AI to execute the `visually_test_app_tests` workflow (baseline visual regression) and the `visually_test_apps` workflow (full remediation loop) for web and mobile experiences using browser automation, research, and UI/UX heuristics.

## visually_test_apps Workflow
When the user requests "visually_test_apps" or asks for a full visual remediation pass, the AI must:

### Persona Activation
- Adopt the combined roles of senior frontend engineer, principal UI/UX designer, visual QA specialist, and web3 product strategist.
- Keep this persona active, narrate reasoning, and store assumptions and research findings in memory.

### Research & Preparation (Exa)
1. Use `exa` to gather late-breaking UI/UX, CSS, and accessibility guidance from the Cursor Community Forum, GitHub, and trusted design blogs.
2. Run targeted queries about Playwright MCP navigation, screenshot capture, and multi-route traversal.
3. Investigate imagery/video best practices for the project's domain (including web3 patterns) and consolidate takeaways into a reusable digest stored in memory.

### Runtime & Intent Mapping
- Detect the framework, required start command, and expected localhost URL. Launch the app and monitor for errors.
- Always bring services up through `scripts/start-visual-test-env.ps1` (wrapped with the watchdog) so API/web dev servers are tracked with PIDs and log files.
- Review PRDs/readme/docs, inspect stylesheets, and inventory assets to understand the intended brand voice and layout strategy.
- If startup or runtime errors appear, capture logs and invoke `create_update_and_run_tests` before proceeding.
- When aborting or finishing a scenario, immediately run `scripts/stop-visual-test-env.ps1 -IncludeBrowsers` to terminate servers and chrome-based automation, then re-launch fresh for the next pass.

### Navigation Queue Construction
- Parse routers/navigation files to build a breadth-first queue of pages, marking authentication prerequisites or lateral siblings.
- Record queue state (pending, visited, grade, issues) in memory so progress survives restarts.

### Page Evaluation Loop
For each queued page:
1. Generate a structured visual specification (layout, hierarchy, colors, typography, motion, interactions, accessibility cues, imagery expectations) derived from code, docs, and the best-practice digest.
2. Use Playwright MCP to navigate to the page, wait for readiness, capture screenshots (and optional DOM snapshots), and persist artifacts via `filesystem`.
3. Compare the screenshot with the expected description. Highlight mismatches or note alignment.
4. When navigation exposes runtime errors, log console/network traces, call `create_update_and_run_tests`, remediate issues, reload the app, and retry the same page.
5. Route to the Visual Remediation Loop when mismatches exist; otherwise continue to the grading loop.
6. Between discrete test cases, close browser contexts or restart Playwright to ensure caches and session storage are cleared.

### Visual Remediation Loop (repeat until screenshot ~ description)
- Diagnose root causes (layout/CSS, component logic, data state, missing assets) and plan the smallest viable fix.
- Prefer new imagery via the `generate_ai_images` workflow or other free sources. Only invoke the `Shutterstock-Automation-Workflow` through `shutterstock-api`/`apify` when free options are insufficient, and capture license metadata.
- Apply targeted code or stylesheet updates while preserving accessibility and project conventions, then save, reload, and recapture with Playwright.
- After any remediation cycle, recycle the browser context (close/reopen) so the UI reloads from a clean state before capturing new evidence.
- Iterate inside this loop until the screenshot and description align to an acceptable tolerance.

### UI/UX Grading Loop (target grade >= A)
- Grade each refreshed page from A–F using the research digest, Nielsen heuristics, WCAG cues, motion guidelines, and web3 trust expectations. Include rationale.
- If the grade is below A, outline the minimal set of improvements needed, implement them (leveraging the remediation loop), retest, and reassess the grade for the same page.
- When the page earns an A or better, log the outcome in memory and return to the navigation queue.

### Asset & Licensing Governance
- Document every asset decision (AI-generated, free stock, Shutterstock) with source, license status, and reasoning.
- Minimise licensed Shutterstock usage and ensure alt text/captions are updated alongside asset changes.

### Completion & Reporting
- Maintain a changelog of modifications, page grades, and remaining risks in memory.
- Continue breadth-first traversal until all pages are graded A or better.
- Produce a final report summarising grades, remediation steps, research references, asset ledger, and recommendations.
- Run `scripts/stop-visual-test-env.ps1 -IncludeBrowsers` even if failures occurred to guarantee no orphaned services or browser processes remain.

### Workflow Integration & Cohesion
- Keep the entire process within this single workflow - do not fork separate modules.
- Call `create_update_and_run_tests` whenever new errors surface.
- Use the original `visually_test_app_tests` workflow when baseline diffing is necessary, but resume this remediation loop afterward.

## visually_test_app_tests Workflow
When the user requests "visually_test_app_tests" or "visual testing", the AI must:

### Step 1: Research Best Practices Using Exa MCP
1. **Search Cursor Community Forum**:
   ```
   Query: "Cursor Community Forum visual testing UI UX design principles frontend best practices"
   ```

2. **Search GitHub**:
   ```
   Query: "GitHub visual testing browser automation screenshot comparison frontend testing best practices"
   ```

3. **Search for browsermcp usage**:
   ```
   Query: "browsermcp navigation screenshot automation best practices visual testing workflow"
   ```

**Important**: Analyze research results and apply best practices to visual testing strategy.

### Step 2: Analyze Project Structure and Start Application
Scan the open workspace to identify:
- Project type (web app, mobile app running in web mode, etc.)
- Main entry point (index.html, main.js, App.js, etc.)
- How to start the application
- All pages/routes in the application
- Create navigation map of all pages to test

#### Technology Detection Commands
```bash
# Detect project type
ls package.json && echo "Node.js project detected"
ls index.html && echo "Static HTML project detected"
ls src/App.js && echo "React project detected"
ls src/main.tsx && echo "React TypeScript project detected"

# Find all pages/routes
find . -name "*.html" -o -name "*.jsx" -o -name "*.tsx" -o -name "*.vue" | grep -v node_modules
grep -r "Route\|router\|navigate" src/ --include="*.js" --include="*.jsx" --include="*.ts" --include="*.tsx"

# Check for routing configuration
grep -r "createBrowserRouter\|BrowserRouter\|Routes\|Route" src/ --include="*.js" --include="*.jsx" --include="*.ts" --include="*.tsx"
```

#### Application Startup
```bash
# Start the application based on project type
npm start 2>/dev/null || npm run dev 2>/dev/null || npm run serve 2>/dev/null || python -m http.server 8000 2>/dev/null || echo "Manual startup required"
```

### Step 3: Generate Page Descriptions
For each page identified:
- Read the HTML/CSS/JS files for the page
- Analyze the stylesheet and component structure
- Generate a detailed description of how the page should look
- Include layout, colors, typography, spacing, and interactive elements
- Create a visual specification for comparison

#### Page Analysis Template
```javascript
// Page description generator
function generatePageDescription(pageFile, stylesheet, components) {
  return {
    layout: analyzeLayout(pageFile),
    colors: extractColors(stylesheet),
    typography: analyzeTypography(stylesheet),
    spacing: analyzeSpacing(stylesheet),
    interactiveElements: identifyInteractiveElements(pageFile),
    responsiveBreakpoints: identifyBreakpoints(stylesheet),
    accessibility: checkAccessibilityFeatures(pageFile),
    expectedVisualHierarchy: determineVisualHierarchy(pageFile, stylesheet)
  };
}

// Detailed analysis functions
function analyzeLayout(pageFile) {
  const layout = {
    structure: 'flexbox', // or 'grid', 'float', 'absolute'
    mainSections: ['header', 'main', 'footer'],
    navigation: 'horizontal', // or 'vertical', 'hamburger'
    contentWidth: 'container', // or 'full-width', 'sidebar'
    alignment: 'center' // or 'left', 'right'
  };
  
  // Analyze HTML structure
  if (pageFile.includes('flex')) layout.structure = 'flexbox';
  if (pageFile.includes('grid')) layout.structure = 'grid';
  if (pageFile.includes('navbar')) layout.navigation = 'horizontal';
  
  return layout;
}

function extractColors(stylesheet) {
  const colors = {
    primary: '#007bff',
    secondary: '#6c757d',
    accent: '#28a745',
    background: '#ffffff',
    text: '#212529',
    links: '#007bff'
  };
  
  // Extract colors from CSS
  const colorRegex = /#[0-9a-fA-F]{6}|#[0-9a-fA-F]{3}|rgb\([^)]+\)|rgba\([^)]+\)/g;
  const foundColors = stylesheet.match(colorRegex) || [];
  
  return { ...colors, found: foundColors };
}
```

### Step 4: Navigate and Capture Screenshots
Use browsermcp to:
- Navigate to the main page (starting point)
- Take a screenshot of the current page
- Navigate to all other pages systematically
- Capture screenshots of each page
- Store screenshots with descriptive filenames

#### Browser Navigation Commands
```javascript
// Using browsermcp tools
await browsermcp_browser_navigate({ url: "http://localhost:3000" });
await browsermcp_browser_wait({ time: 2 }); // Wait for page load
await browsermcp_browser_screenshot({ random_string: "main-page" });

// Navigate through all pages
const pages = ["/", "/about", "/contact", "/products", "/login"];
for (const page of pages) {
  await browsermcp_browser_navigate({ url: `http://localhost:3000${page}` });
  await browsermcp_browser_wait({ time: 2 });
  await browsermcp_browser_screenshot({ random_string: `page-${page.replace('/', '')}` });
}
```

#### Screenshot Management
```javascript
// Screenshot organization and storage
class ScreenshotManager {
  constructor() {
    this.screenshots = new Map();
    this.baseUrl = 'http://localhost:3000';
  }
  
  async capturePage(pagePath, description) {
    const url = `${this.baseUrl}${pagePath}`;
    await browsermcp_browser_navigate({ url });
    await browsermcp_browser_wait({ time: 2 });
    
    const screenshot = await browsermcp_browser_screenshot({ 
      random_string: `page-${pagePath.replace('/', '')}-${Date.now()}` 
    });
    
    this.screenshots.set(pagePath, {
      url,
      screenshot,
      description,
      timestamp: new Date().toISOString()
    });
    
    return screenshot;
  }
}
```

### Step 5: Visual Comparison and Mismatch Detection
For each screenshot:
- Compare the actual screenshot with the generated description
- Identify visual mismatches and discrepancies
- Analyze layout issues, color problems, typography issues
- Detect missing elements or incorrect positioning
- Generate a detailed mismatch report

#### Visual Comparison Logic
```javascript
function compareVisualWithDescription(screenshot, description) {
  const mismatches = [];
  
  // Check layout structure
  if (!matchesLayout(screenshot, description.layout)) {
    mismatches.push({
      type: 'layout',
      issue: 'Layout structure does not match expected design',
      severity: 'high'
    });
  }
  
  // Check color scheme
  if (!matchesColors(screenshot, description.colors)) {
    mismatches.push({
      type: 'colors',
      issue: 'Color scheme does not match expected palette',
      severity: 'medium'
    });
  }
  
  // Check typography
  if (!matchesTypography(screenshot, description.typography)) {
    mismatches.push({
      type: 'typography',
      issue: 'Typography does not match expected styles',
      severity: 'medium'
    });
  }
  
  return mismatches;
}
```

### Step 6: Automatic Fix Loop (Mismatch Branch)
If mismatches are detected:
- Enter a separate fixing loop
- Analyze each mismatch and determine the root cause
- Generate code fixes for the identified issues
- Apply minimal code changes to address only the specific problems
- Save the modified files
- Reload the page and retake screenshot
- Repeat until screenshot matches description sufficiently

#### Auto-Fix Implementation
```javascript
async function autoFixLoop(pageFile, mismatches, screenshot) {
  let attempts = 0;
  const maxAttempts = 5;
  
  while (mismatches.length > 0 && attempts < maxAttempts) {
    attempts++;
    
    // Analyze each mismatch
    for (const mismatch of mismatches) {
      const fix = generateFix(mismatch, pageFile);
      if (fix) {
        applyFix(fix);
        await saveFile(pageFile);
      }
    }
    
    // Reload page and retake screenshot
    await browsermcp_browser_navigate({ url: currentUrl });
    await browsermcp_browser_wait({ time: 2 });
    const newScreenshot = await browsermcp_browser_screenshot({ random_string: "fixed-page" });
    
    // Re-evaluate mismatches
    mismatches = compareVisualWithDescription(newScreenshot, description);
  }
  
  return mismatches.length === 0;
}
```

### Step 7: UI/UX Grading System
Once visual matches are achieved:
- Grade the page on UI/UX design principles
- Use a scale from A to F
- Provide detailed rationale for the grade
- Consider accessibility, usability, visual hierarchy, and modern design principles

#### UI/UX Grading Criteria
```javascript
function gradeUIUX(screenshot, description) {
  const criteria = {
    visualHierarchy: evaluateVisualHierarchy(screenshot),
    accessibility: evaluateAccessibility(screenshot),
    usability: evaluateUsability(screenshot),
    modernDesign: evaluateModernDesign(screenshot),
    responsiveDesign: evaluateResponsiveDesign(screenshot),
    colorHarmony: evaluateColorHarmony(screenshot),
    typography: evaluateTypography(screenshot),
    spacing: evaluateSpacing(screenshot),
    interactiveElements: evaluateInteractiveElements(screenshot)
  };
  
  const scores = Object.values(criteria);
  const averageScore = scores.reduce((sum, score) => sum + score, 0) / scores.length;
  
  return {
    grade: getLetterGrade(averageScore),
    score: averageScore,
    criteria: criteria,
    rationale: generateRationale(criteria, averageScore)
  };
}

function getLetterGrade(score) {
  if (score >= 90) return 'A';
  if (score >= 80) return 'B';
  if (score >= 70) return 'C';
  if (score >= 60) return 'D';
  return 'F';
}

// Detailed evaluation functions
function evaluateVisualHierarchy(screenshot) {
  // Check for clear heading structure, content organization
  let score = 50;
  
  // Look for heading elements (H1, H2, H3)
  if (screenshot.includes('h1')) score += 20;
  if (screenshot.includes('h2')) score += 15;
  if (screenshot.includes('h3')) score += 10;
  
  // Check for proper content sections
  if (screenshot.includes('main')) score += 15;
  if (screenshot.includes('section')) score += 10;
  
  return Math.min(score, 100);
}

function evaluateAccessibility(screenshot) {
  let score = 50;
  
  // Check for alt text on images
  if (screenshot.includes('alt=')) score += 20;
  
  // Check for proper form labels
  if (screenshot.includes('label')) score += 15;
  
  // Check for ARIA attributes
  if (screenshot.includes('aria-')) score += 15;
  
  return Math.min(score, 100);
}

function evaluateModernDesign(screenshot) {
  let score = 50;
  
  // Check for modern CSS features
  if (screenshot.includes('flexbox') || screenshot.includes('grid')) score += 20;
  if (screenshot.includes('border-radius')) score += 15;
  if (screenshot.includes('box-shadow')) score += 15;
  
  return Math.min(score, 100);
}
```

### Step 8: UI/UX Improvement Loop (Grade Below A)
If the grade is below A:
- Enter another improvement loop
- Take the grade and rationale as input
- Generate specific improvements for the identified issues
- Apply minimal code changes to improve UI/UX
- Save and recompile the page
- Restart the workflow from the beginning for this page

#### Improvement Implementation
```javascript
async function improvementLoop(pageFile, grade, rationale) {
  const improvements = generateImprovements(grade, rationale);
  
  for (const improvement of improvements) {
    const codeChanges = generateCodeChanges(improvement, pageFile);
    applyCodeChanges(codeChanges);
    await saveFile(pageFile);
  }
  
  // Recompile/restart if necessary
  await restartApplication();
  
  // Restart workflow for this page
  return await startVisualTestingWorkflow(pageFile);
}
```

### Step 9: Page Completion and Navigation
When a page receives grade A or higher:
- Mark the page as completed
- Move to the next page in the navigation map
- Continue the workflow for all remaining pages
- Maintain a completion log

#### Navigation Management
```javascript
const pageQueue = ["/", "/about", "/contact", "/products", "/login"];
const completedPages = [];
const currentPageIndex = 0;

async function navigateToNextPage() {
  if (currentPageIndex < pageQueue.length - 1) {
    currentPageIndex++;
    const nextPage = pageQueue[currentPageIndex];
    await browsermcp_browser_navigate({ url: `http://localhost:3000${nextPage}` });
    return nextPage;
  }
  return null; // All pages completed
}
```

### Step 10: Final Report Generation
After all pages are tested and fixed:
- Generate a comprehensive report of all pages tested
- Include before/after screenshots
- Document all fixes applied
- Provide overall UI/UX assessment
- Create recommendations for future improvements

#### Report Generation
```javascript
function generateFinalReport() {
  return {
    totalPages: pageQueue.length,
    completedPages: completedPages.length,
    averageGrade: calculateAverageGrade(completedPages),
    totalFixes: countTotalFixes(),
    improvements: documentImprovements(),
    recommendations: generateRecommendations(),
    screenshots: organizeScreenshots(),
    timeline: documentWorkflowTimeline()
  };
}
```

## Mandatory Full Page Screenshots Rule
**CRITICAL**: ALL screenshots taken during visual testing MUST be full page screenshots using `fullPage: true` parameter.

### Screenshot Requirements:
- **Always use**: `fullPage: true` for ALL screenshot operations
- **Never use**: Viewport-only screenshots unless specifically requested
- **Purpose**: Capture complete page layout, footer, and all content
- **Integration**: This rule applies to ALL projects using the startup process

### Implementation:
```javascript
// CORRECT - Full page screenshot
await browsermcp_browser_screenshot({ 
  random_string: "page-name",
  fullPage: true  // MANDATORY
});

// INCORRECT - Viewport only
await browsermcp_browser_screenshot({ 
  random_string: "page-name"
  // Missing fullPage: true
});
```

### Enforcement:
- This rule is automatically loaded via the startup process
- All visual testing workflows MUST follow this rule
- Screenshots without `fullPage: true` are considered incomplete
- This ensures consistent documentation across all projects

## Key Principles
1. **Minimize Code Changes**: Only make necessary changes to fix specific issues
2. **Prioritize User Experience**: Ensure fixes improve overall user experience
3. **Iterative Improvement**: Use loops to continuously refine until standards are met
4. **Comprehensive Coverage**: Test all pages and routes in the application
5. **Visual Consistency**: Ensure consistent design across all pages
6. **Accessibility First**: Maintain accessibility standards throughout
7. **Full Page Documentation**: ALL screenshots must capture complete page content

## Success Criteria
The workflow is complete when:
- âœ… All pages have been visually tested
- âœ… All visual mismatches have been resolved
- âœ… All pages receive grade A or higher
- âœ… UI/UX improvements have been applied
- âœ… Final report has been generated
- âœ… Application maintains functionality

## Error Handling
When issues occur:
1. Log detailed error information
2. Attempt to recover from browser automation failures
3. Provide fallback methods for screenshot capture
4. Continue workflow with remaining pages
5. Generate error report for manual review

## Integration with Existing Workflows
This visual testing workflow integrates with:
- Comprehensive testing workflows
- AWS deployment workflows
- Mobile app deployment workflows
- Web application deployment workflows

The AI must ensure all deployed applications meet visual and UI/UX standards before deployment completion.





